# 复习侧重点概览

- **排序算法与复杂度分析**
  - **归并排序（Merge Sort）**  
    在 2019 年考题中要求对归并排序及其合并（merge）步骤进行解释并分析其时间复杂度；2021 年也出现了“归并合并步骤”和“整题归并排序复杂度”的命题；2024 年要求描述归并排序算法并分析其在 \(n\) 大小输入下的复杂度。由此可见，掌握归并排序的原理、合并过程以及 \(O(n\log n)\) 复杂度证明至关重要。 fileciteturn0file0turn0file1turn0file2
  - **堆排序（Heap Sort）与堆结构**  
    2021 年考题要求解释堆数据结构及其如何用于对 \(n\) 个整数进行升序排序，并分析其复杂度；2024 年题目中的 Q4(b) 同样考察“根节点删除后如何维持堆属性”与“优先队列如何用堆实现”；示例试卷（example1.pdf）也重复了“堆排序”与“堆结构”的考察。需要重点掌握堆的性质（大顶堆/小顶堆）、插入与删除（heapify）操作的 \(O(\log n)\) 复杂度，以及利用堆实现排序的整个过程（建堆 \(O(n)\)，再逐次提取最小/最大元素）。 fileciteturn0file1turn0file2turn0file3  
  - **快速排序（Quick Sort）**  
    虽然快速排序在 2019–2024 年原题中并未直接出现，但在 example2.pdf（往年练习题）中明确要求“用自己的话解释 QuickSort 算法及其最坏情况复杂度和递推式”，可见快速排序是核心排序算法组中的重要成员，应掌握其分治思想、划分（partition）策略，以及最坏情形 \(O(n^2)\) 和平均情况 \(O(n\log n)\) 的推导。 fileciteturn0file4  
  - **插入排序（Insertion Sort）**  
    2024 年 Q1(b) 问“给一个输入示例使插入排序达到 \(O(n)\)”，并比较相同输入下归并排序与堆排序的复杂度；意味着必须理解“几乎有序数组”下插入排序的线性行为。 fileciteturn0file2  

- **数据结构基础与实现**
  - **链表（Linked List）**  
    2019 年 Q1(a) 中需要“用 Java 类实现优先队列（基于链表）”，并在 2019 和 2021 年又分别要求“编写单链表节点（Link）和双链表节点（DoubleLink）的类定义及构造函数（仅限 Java）”，以及“给定一个双链表节点 current，实现 insertBefore() 方法，将新节点插入到 current 之前”操作。由此可知，对于单链表和双链表的节点设计、构造函数赋值、指针处理（前驱/后继指针）以及插入删除操作，必须理解并能熟练编写。 fileciteturn0file0turn0file1  
  - **优先队列（Priority Queue）**  
    优先队列的链表实现出现在 2019 年 Q1(a)；2021 年、2024 年、示例题典型地都考察“如何用二叉堆实现优先队列”，并进一步在图算法题中用作 Dijkstra 算法与 Kruskal 算法的子步骤。应重点掌握：  
    1. **基于链表**：如何维护插入顺序或按优先级插入的逻辑，以及插入/删除的时间复杂度分析。 fileciteturn0file0  
    2. **基于堆**：二叉堆的“堆属性”，插入（up-heap）与删除（down-heap）、建堆方法，以及构建堆的 \(O(n)\) 与 \(	ext{extract-min}\) 的 \(O(\log n)\) 复杂度。 fileciteturn0file1turn0file2  

- **算法分析与复杂度比较**
  - **渐近记号（Big-O、Big-Θ、Big-Ω）**  
    2019 年 Q3(a) 要求给出形式化定义；Q3(b) 具体“证明 \(n\log n = O(n^2)\)”和“证明 \(n^3\log n \notin O(n^2)\)”。2021 年 Q3(a) 也要求“说明为什么 \(O(n^2)\subset O(n^3)\) 且 \(O(n^2)\not\subset O(n)\)”。2024 年 Q3(a) 列出了多个复杂度表达式（如 \(O(2^{0.3n})\)、\(O(n^{0.5})\)、\(O(\log n)\)、\(O(n)\)、\(O(n\log n)\)、\(O(n^2\log n)\)），要求按升序排列并解释其增长顺序。因此，必须能够：  
    1. 写出渐近符号的严格定义及判定方法；  
    2. 比较常见函数（多项式、对数、指数）的大小关系并正确排序；  
    3. 针对具体函数，给出相应的证明或反例。 fileciteturn0file0turn0file1turn0file2  
  - **递推关系与主定理（Master Theorem）**  
    示例题（example2.pdf）Q1(b) 直接要求写出 QuickSort 的递推式；部分题目隐式考察归并排序、快速排序分治法的递推式并计算复杂度，需要熟练掌握主定理、递归树法以及递推关系的推导与求解。 fileciteturn0file4  
  - **摊还分析（Amortized Analysis）**  
    2021 年 Q3(b) 和 2024 年 Q3(b) 都考察“multiDequeue(i)”或“multiPop(i)”的摊还复杂度（均为 \(O(1)\)），需要理解执行多次单次操作时如何通过摊还法证明平均每次操作的代价为常数。 fileciteturn0file1turn0file2  

- **图算法与最短路径 / 最小生成树**
  - **Kruskal 最小生成树算法**  
    2019 年 Q4(a)、2021 年 Q4(b)、2024 年 Q5(a) 以及示例题均反复出现 Kruskal 算法，要求：  
    1. 解释 Kruskal 算法核心思想（按边权排序，逐条选边并用并查集/Disjoint Set Union 检测环）；  
    2. 论证为什么能保证构造最小生成树且避免循环；  
    3. 分析整体复杂度（主要在排序边 \(O(E\log E)\) 以及并查集操作的近似 \(O(\alpha(V))\)）。  
    重点在于掌握并查集数据结构的实现（路径压缩、按秩合并）及其在 Kruskal 中的应用。 fileciteturn0file0turn0file1turn0file2  
  - **Dijkstra 单源最短路径算法**  
    2019 年 Q4(b)、2021 年 Q5(a)、2024 年 Q5(b) 和示例题都考察 Dijkstra。其重点在于：  
    1. 算法思想：在非负权图中，每次选取当前未“定型”节点中距源距离最小者并松弛其所有出边；  
    2. 若用线性扫描选最小顶点，需要 \(O(V^2)\)；若用二叉堆做优先队列，需要 \(O((V+E)\log V)\)；若用斐波那契堆，可优化到 \(O(V\log V + E)\)。  
    3. 理解“松弛（relax）”操作、优先队列更新（decrease-key）机制，以及实现细节。 fileciteturn0file0turn0file1turn0file2  
  - **Bellman-Ford 单源最短路径算法**  
    虽然在 2019–2024 原卷中未直接出现，但 example2.pdf Q4(b) 专门考察 Bellman-Ford 算法，需要熟悉其“迭代松弛”思想、能检测负权回路的机制，以及复杂度 \(O(VE)\)。 fileciteturn0file4  
  - **Floyd–Warshall 全点对最短路径算法**  
    2019 年 Q5(b)、2021 年 Q5(b)、2024 年 Q5(b) 以及示例题都要求阐述 Floyd 算法的动态规划思想：  
    1. 初始化距离矩阵 \(	ext{dist}[i][j]\)；  
    2. 按照“引入中间顶点 \(k\)”的顺序，不断更新 \(	ext{dist}[i][j] = \min(	ext{dist}[i][j],\, 	ext{dist}[i][k] + 	ext{dist}[k][j])\)；  
    3. 时间复杂度为 \(O(n^3)\)，空间复杂度为 \(O(n^2)\)。  
    需要理解状态转移方程与三重循环的实现。 fileciteturn0file0turn0file1turn0file2  

- **树与图的遍历**
  - **二叉树遍历（Inorder/Preorder/Postorder）**  
    2019 年 Q5(a)、2021 年 Q4(a)、2024 年 Q4(a) 反复命题：要求分别说明“中序（左-根-右）”、“先序（根-左-右）”、“后序（左-右-根）”遍历的过程，并能给出具体树的遍历序列。往年试题中通常附带一棵图示二叉树，让考生演示节点访问顺序。需要熟悉递归与非递归两种实现思路，并能分析其时间复杂度 \(O(n)\)。 fileciteturn0file0turn0file1turn0file2  
  - **广度优先搜索（BFS）与深度优先搜索（DFS）**  
    2021 年 Q4(a) 要求“用 BFS 判断无向图的连通分量数”，示例题（example2.pdf） Q3(b) 要求“用非递归方式对图进行 DFS 并解释”，并分析其复杂度为 \(O(V+E)\)。应重点掌握：  
    1. BFS 用队列保存当前层节点，并依次访问所有邻接；能用于判断连通分量、最短路径（在无权图）；  
    2. DFS 用栈实现（递归即隐式栈），可用于拓扑排序、连通性检测等；  
    3. 时空复杂度均为 \(O(V+E)\)。 fileciteturn0file1turn0file4  

- **设计特定算法与问题求解**
  - **第 \(k\) 小元素（k-th Smallest）**  
    2019 年 Q2(a) 要求“设计一个比 \(O(n\log n)\) 更快的算法，查找长度为 \(n\) 的无序数组中的第 \(k\) 小元素（假设 \(k\) 为常数）”；2024 年 Q2(a) 要求“对两个已排序数组 \(A\)（长度 \(n\）和 \(B\)（长度 \(m\）），在 \(O(\log n + \log m\）或类似时间内找到合并后第 \(k\) 小元素”。两个题目都侧重于“利用堆选择或分治取中位数”或“在两个有序数组中做二分查找”的思路，并分析时间复杂度需优于 \(O(n)\）或 \(O(m+n)\）。 fileciteturn0file0turn0file2  
  - **Two-Sum 问题**  
    2024 年 Q2(b) 中提出“给定一个升序数组 \(A\）和整数 \(q\），设计算法判断是否存在 \(r,s\in A\）使得 \(r+s=q\），要求 \(O(n)\）时间”，典型解法是双指针从两端向中间逼近。此外，example2.pdf Q3(a) 要求类似问题但对无序数组，需先排序或用哈希表 O(n) 解决。需掌握双指针、哈希表及排序后寻找的思路并分析其时间/空间复杂度。 fileciteturn0file2turn0file4
